{{- if .Values.tekton.enabled }}
---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: docling-parse-pdfs
  namespace: {{ include "agentic-claims-demo.namespace" . }}
  labels:
    {{- include "agentic-claims-demo.labels" . | nindent 4 }}
    app.kubernetes.io/component: tekton-task
spec:
  description: >
    Parse PDFs using Docling and extract text content.
    Updates claim_documents with extracted OCR text.

  params:
    - name: pdf-path
      type: string
      description: Path to PDFs directory
      default: /workspace/pdfs

  workspaces:
    - name: pdfs
      description: Workspace containing PDFs to parse
      mountPath: /workspace/pdfs

  steps:
    - name: install-dependencies
      image: registry.access.redhat.com/ubi9/python-312:latest
      script: |
        #!/bin/bash
        set -e
        echo "Installing Python dependencies..."
        pip install --no-cache-dir \
          docling==2.18.0 \
          sqlalchemy==2.0.36 \
          psycopg2-binary==2.9.10
        echo "✓ Dependencies installed"

    - name: docling-parse
      image: registry.access.redhat.com/ubi9/python-312:latest
      env:
        - name: POSTGRES_HOST
          value: {{ .Values.postgresql.service.name | default "postgresql" }}.{{ include "agentic-claims-demo.namespace" . }}.svc.cluster.local
        - name: POSTGRES_PORT
          value: "5432"
        - name: POSTGRES_DATABASE
          valueFrom:
            secretKeyRef:
              name: {{ .Values.postgresql.auth.existingSecret }}
              key: {{ .Values.postgresql.auth.secretKeys.databaseKey }}
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: {{ .Values.postgresql.auth.existingSecret }}
              key: {{ .Values.postgresql.auth.secretKeys.userNameKey }}
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: {{ .Values.postgresql.auth.existingSecret }}
              key: {{ .Values.postgresql.auth.secretKeys.userPasswordKey }}
        - name: PDF_DIR
          value: $(params.pdf-path)
      script: |
        #!/usr/bin/env python3
        """Parse PDFs using Docling and update database."""

        import logging
        import os
        import sys
        from pathlib import Path

        from docling.document_converter import DocumentConverter
        from sqlalchemy import create_engine, text
        from sqlalchemy.orm import sessionmaker

        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
        logger = logging.getLogger(__name__)

        DATABASE_URL = f"postgresql://{os.getenv('POSTGRES_USER')}:{os.getenv('POSTGRES_PASSWORD')}@{os.getenv('POSTGRES_HOST')}:{os.getenv('POSTGRES_PORT')}/{os.getenv('POSTGRES_DATABASE')}"
        PDF_DIR = os.getenv('PDF_DIR', '/workspace/pdfs')

        def parse_pdf(pdf_path):
            """Parse PDF with Docling."""
            converter = DocumentConverter()
            result = converter.convert(pdf_path)
            return result.document.export_to_text().strip()

        def main():
            logger.info(f"Parsing PDFs from {PDF_DIR}")
            pdf_path = Path(PDF_DIR)

            if not pdf_path.exists():
                logger.error(f"PDF directory not found: {PDF_DIR}")
                sys.exit(1)

            engine = create_engine(DATABASE_URL, pool_pre_ping=True)
            SessionLocal = sessionmaker(bind=engine)

            with SessionLocal() as session:
                query = text("""
                    SELECT CAST(cd.id AS text) as doc_id, c.claim_number, cd.file_path
                    FROM claim_documents cd
                    JOIN claims c ON cd.claim_id = c.id
                    WHERE cd.raw_ocr_text IS NOT NULL
                    ORDER BY c.claim_number
                """)
                documents = session.execute(query).fetchall()

            logger.info(f"Found {len(documents)} documents to parse")
            parsed = 0
            failed = 0

            for row in documents:
                filename = Path(row.file_path).name
                pdf_file = pdf_path / filename

                if not pdf_file.exists():
                    logger.error(f"PDF not found: {pdf_file}")
                    failed += 1
                    continue

                logger.info(f"Parsing {row.claim_number}...")
                try:
                    extracted_text = parse_pdf(str(pdf_file))

                    with SessionLocal() as session:
                        update_query = text("""
                            UPDATE claim_documents
                            SET raw_ocr_text = :ocr_text,
                                ocr_confidence = 0.95,
                                ocr_processed_at = NOW()
                            WHERE CAST(id AS text) = :doc_id
                        """)
                        session.execute(update_query, {
                            "ocr_text": extracted_text,
                            "doc_id": row.doc_id
                        })
                        session.commit()

                    parsed += 1
                    logger.info(f"  ✅ Parsed ({parsed}/{len(documents)})")

                    if parsed % 10 == 0:
                        logger.info(f"Progress: {parsed}/{len(documents)}")

                except Exception as e:
                    logger.error(f"  ❌ Failed: {e}")
                    failed += 1

            logger.info(f"✅ Parsed: {parsed}/{len(documents)}")
            logger.info(f"❌ Failed: {failed}/{len(documents)}")
            engine.dispose()

            if failed > 0:
                sys.exit(1)

        if __name__ == "__main__":
            main()
      resources:
        requests:
          cpu: 1000m
          memory: 4Gi
        limits:
          cpu: 2000m
          memory: 8Gi
{{- end }}
